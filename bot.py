import os
import asyncio
import logging
import random
import time
from typing import Dict, List, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from telegram.constants import ParseMode
import yt_dlp
import aiofiles
from dotenv import load_dotenv

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦ÙŠØ©
load_dotenv()

# Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª
BOT_TOKEN = os.getenv('BOT_TOKEN')
DOWNLOAD_PATH = os.getenv('DOWNLOAD_PATH', './downloads/')
USE_PROXY = os.getenv('USE_PROXY', 'false').lower() == 'true'
PROXY_URL = os.getenv('PROXY_URL', '')

# Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
os.makedirs(DOWNLOAD_PATH, exist_ok=True)

# Ù‚Ø§Ø¦Ù…Ø© User Agents Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù„ØªØ¬Ù†Ø¨ Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø¨ÙˆØª
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
]

class YouTubeTelegramBot:
    def __init__(self):
        self.user_sessions: Dict[int, Dict] = {}
        
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø£Ù…Ø± /start"""
        welcome_message = """
ğŸ¬ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª!

ğŸ“‹ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:
â€¢ ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ù…Ù† ÙŠÙˆØªÙŠÙˆØ¨
â€¢ Ø§Ø®ØªÙŠØ§Ø± Ø¬ÙˆØ¯Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
â€¢ Ø§Ø®ØªÙŠØ§Ø± ØµÙŠØºØ© Ø§Ù„ØªØ­Ù…ÙŠÙ„ (ÙÙŠØ¯ÙŠÙˆ/ØµÙˆØª)

ğŸ“ ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:
1. Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ù† ÙŠÙˆØªÙŠÙˆØ¨
2. Ø§Ø®ØªØ± Ø§Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
3. Ø§Ø®ØªØ± Ø§Ù„ØµÙŠØºØ© (ÙÙŠØ¯ÙŠÙˆ Ø£Ùˆ ØµÙˆØª ÙÙ‚Ø·)
4. Ø§Ù†ØªØ¸Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„ ÙˆØ§Ù„Ø¥Ø±Ø³Ø§Ù„

ğŸ”— Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø¢Ù†!
        """
        
        await update.message.reply_text(
            welcome_message,
            parse_mode=ParseMode.MARKDOWN
        )

    async def handle_url(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù…Ø±Ø³Ù„Ø©"""
        url = update.message.text.strip()
        user_id = update.message.from_user.id
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ø§Ø¨Ø·
        if not self.is_valid_youtube_url(url):
            await update.message.reply_text(
                "âŒ Ø§Ù„Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ­ÙŠØ­!\n"
                "ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· ØµØ­ÙŠØ­ Ù…Ù† ÙŠÙˆØªÙŠÙˆØ¨."
            )
            return
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù†ØªØ¸Ø§Ø±
        loading_message = await update.message.reply_text(
            "ğŸ” Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±..."
        )
        
        try:
            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
            video_info = await self.get_video_info(url)
            
            if not video_info:
                await loading_message.edit_text(
                    "âŒ ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ!\n"
                    "ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ø§Ø¨Ø· ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
                )
                return
            
            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
            if 'error' in video_info:
                error_type = video_info.get('error')
                error_messages = {
                    'geo_restricted': "ğŸŒ **Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØºÙŠØ± Ù…ØªØ§Ø­ ÙÙŠ Ø¨Ù„Ø¯Ùƒ**\n\n"
                                    "ğŸ’¡ **Ø§Ù„Ø­Ù„ÙˆÙ„ Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©:**\n"
                                    "â€¢ Ø§Ø³ØªØ®Ø¯Ù… VPN Ù„Ù„Ø§ØªØµØ§Ù„ Ù…Ù† Ø¨Ù„Ø¯ Ø¢Ø®Ø±\n"
                                    "â€¢ Ø¬Ø±Ø¨ Ø±Ø§Ø¨Ø·Ø§Ù‹ Ø¢Ø®Ø± Ù…Ù† Ù†ÙØ³ Ø§Ù„Ù‚Ù†Ø§Ø©\n"
                                    "â€¢ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨Ø±ÙˆÙƒØ³ÙŠ",
                    
                    'login_required': "ğŸ”’ **ÙŠÙˆØªÙŠÙˆØ¨ ÙŠØ·Ù„Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„**\n\n"
                                    "ğŸ’¡ **Ø§Ù„Ø­Ù„ÙˆÙ„ Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©:**\n"
                                    "â€¢ Ø§Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\n"
                                    "â€¢ Ø§Ø³ØªØ®Ø¯Ù… VPN Ù„Ù„ØªØºÙŠÙŠØ± Ù…Ù† Ù…ÙˆÙ‚Ø¹Ùƒ\n"
                                    "â€¢ Ø¬Ø±Ø¨ ÙÙŠØ¯ÙŠÙˆ Ø¢Ø®Ø± Ù…Ù† Ù‚Ù†Ø§Ø© Ù…Ø®ØªÙ„ÙØ©",
                    
                    'unavailable': "âŒ **Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØºÙŠØ± Ù…ØªØ§Ø­**\n\n"
                                 "ğŸ’¡ **Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ù…Ø­ØªÙ…Ù„Ø©:**\n"
                                 "â€¢ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ø­Ø°ÙˆÙ Ø£Ùˆ Ø®Ø§Øµ\n"
                                 "â€¢ Ø§Ù„Ù‚Ù†Ø§Ø© Ù…Ø­Ø¸ÙˆØ±Ø© Ø£Ùˆ Ù…Ø¹Ù„Ù‚Ø©\n"
                                 "â€¢ Ù…Ø´ÙƒÙ„Ø© Ù…Ø¤Ù‚ØªØ© ÙÙŠ ÙŠÙˆØªÙŠÙˆØ¨",
                    
                    'extraction_failed': "âš ï¸ **ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ**\n\n"
                                       "ğŸ’¡ **Ø¬Ø±Ø¨:**\n"
                                       "â€¢ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø§Ø¨Ø·\n"
                                       "â€¢ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ø§Ø¨Ø·\n"
                                       "â€¢ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹",
                }
                
                error_msg = error_messages.get(error_type, "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ!")
                await loading_message.edit_text(error_msg, parse_mode=ParseMode.MARKDOWN)
                return
            
            # Ø­ÙØ¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ù„Ø³Ø©
            self.user_sessions[user_id] = {
                'url': url,
                'video_info': video_info,
                'message_id': loading_message.message_id
            }
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª
            keyboard = self.create_quality_keyboard(video_info)
            
            video_title = video_info.get('title', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')[:50]
            duration = self.format_duration(video_info.get('duration', 0))
            uploader = video_info.get('uploader', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            
            info_text = f"""
ğŸ“¹ **Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ:**

ğŸ¬ **Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** {video_title}
ğŸ‘¤ **Ø§Ù„Ù‚Ù†Ø§Ø©:** {uploader}
â±ï¸ **Ø§Ù„Ù…Ø¯Ø©:** {duration}

ğŸ“Š Ø§Ø®ØªØ± Ø¬ÙˆØ¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„:
            """
            
            await loading_message.edit_text(
                info_text,
                reply_markup=keyboard,
                parse_mode=ParseMode.MARKDOWN
            )
            
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø§Ø¨Ø·: {e}")
            await loading_message.edit_text(
                "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø§Ø¨Ø·!\n"
                "ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
            )

    def is_valid_youtube_url(self, url: str) -> bool:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø±Ø§Ø¨Ø· ÙŠÙˆØªÙŠÙˆØ¨"""
        youtube_domains = ['youtube.com', 'youtu.be', 'www.youtube.com', 'm.youtube.com']
        return any(domain in url for domain in youtube_domains)

    def get_ydl_opts(self, for_download: bool = False) -> Dict:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø®ÙŠØ§Ø±Ø§Øª yt-dlp Ù…Ø­Ø³Ù†Ø©"""
        opts = {
            'quiet': True,
            'no_warnings': True,
            'user_agent': random.choice(USER_AGENTS),
            'sleep_interval': random.uniform(1, 3),
            'max_sleep_interval': 5,
            'extractor_retries': 3,
            'fragment_retries': 3,
            'retry_sleep_functions': {
                'http': lambda n: random.uniform(1, 3) * (2 ** n),
                'fragment': lambda n: random.uniform(1, 2) * (2 ** n),
            },
            # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„ØªØ¬Ù†Ø¨ Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø¨ÙˆØª
            'http_headers': {
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9,ar;q=0.8',
                'Accept-Encoding': 'gzip, deflate',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
            # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ø¤Ù‚ØªØ©
            'ignoreerrors': False,
            'extract_flat': False,
        }
        
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ø§Ù‹
        if USE_PROXY and PROXY_URL:
            opts['proxy'] = PROXY_URL
            logger.info("Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ Ù„Ù„Ø§ØªØµØ§Ù„")
        
        # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„ØªØ­Ù…ÙŠÙ„
        if for_download:
            opts.update({
                'writesubtitles': False,
                'writeautomaticsub': False,
                'writedescription': False,
                'writeinfojson': False,
                'writethumbnail': False,
            })
        
        return opts

    async def get_video_info(self, url: str) -> Optional[Dict]:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙØ¶Ù„ Ù„Ù„Ø£Ø®Ø·Ø§Ø¡"""
        max_retries = 3
        
        for attempt in range(max_retries):
            try:
                # Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª
                if attempt > 0:
                    delay = random.uniform(2, 5) * attempt
                    logger.info(f"Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {attempt + 1} Ø¨Ø¹Ø¯ {delay:.1f} Ø«Ø§Ù†ÙŠØ©...")
                    await asyncio.sleep(delay)
                
                ydl_opts = self.get_ydl_opts()
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = await asyncio.to_thread(ydl.extract_info, url, download=False)
                    return info
                    
            except yt_dlp.utils.GeoRestrictedError as e:
                logger.error(f"Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØºÙŠØ± Ù…ØªØ§Ø­ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø¨Ù„Ø¯: {e}")
                return {'error': 'geo_restricted', 'message': str(e)}
                
            except yt_dlp.utils.ExtractorError as e:
                error_msg = str(e).lower()
                if 'sign in' in error_msg or 'not a bot' in error_msg:
                    logger.error(f"ÙŠÙˆØªÙŠÙˆØ¨ ÙŠØ·Ù„Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„: {e}")
                    return {'error': 'login_required', 'message': str(e)}
                elif 'private' in error_msg or 'unavailable' in error_msg:
                    logger.error(f"Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØºÙŠØ± Ù…ØªØ§Ø­: {e}")
                    return {'error': 'unavailable', 'message': str(e)}
                else:
                    logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {e}")
                    if attempt == max_retries - 1:
                        return {'error': 'extraction_failed', 'message': str(e)}
                    
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ Ø¹Ø§Ù… ÙÙŠ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {e}")
                if attempt == max_retries - 1:
                    return {'error': 'unknown', 'message': str(e)}
        
        return None

    def create_quality_keyboard(self, video_info: Dict) -> InlineKeyboardMarkup:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¬ÙˆØ¯Ø©"""
        keyboard = []
        
        # Ø¬ÙˆØ¯Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…ØªØ§Ø­Ø©
        formats = video_info.get('formats', [])
        video_formats = {}
        
        for fmt in formats:
            if fmt.get('vcodec') != 'none' and fmt.get('height'):
                height = fmt.get('height')
                ext = fmt.get('ext', 'mp4')
                if height not in video_formats or fmt.get('filesize', 0) > video_formats[height].get('filesize', 0):
                    video_formats[height] = fmt
        
        # ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¬ÙˆØ¯Ø§Øª Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰ Ù„Ù„Ø£Ù‚Ù„
        sorted_qualities = sorted(video_formats.keys(), reverse=True)
        
        # Ø¥Ø¶Ø§ÙØ© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¬ÙˆØ¯Ø©
        for quality in sorted_qualities[:6]:  # Ø£ÙˆÙ„ 6 Ø¬ÙˆØ¯Ø§Øª
            quality_text = f"ğŸ“¹ {quality}p"
            callback_data = f"video_{quality}"
            keyboard.append([InlineKeyboardButton(quality_text, callback_data=callback_data)])
        
        # Ø¥Ø¶Ø§ÙØ© Ø®ÙŠØ§Ø± Ø§Ù„ØµÙˆØª ÙÙ‚Ø·
        keyboard.append([InlineKeyboardButton("ğŸµ ØµÙˆØª ÙÙ‚Ø· (MP3)", callback_data="audio_mp3")])
        
        # Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ø§Ù„Ø¥Ù„ØºØ§Ø¡
        keyboard.append([InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel")])
        
        return InlineKeyboardMarkup(keyboard)

    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø²Ø±Ø§Ø±"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        data = query.data
        
        if user_id not in self.user_sessions:
            await query.edit_message_text("âŒ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¬Ù„Ø³Ø©. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ø¬Ø¯ÙŠØ¯.")
            return
        
        if data == "cancel":
            del self.user_sessions[user_id]
            await query.edit_message_text("âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.")
            return
        
        session = self.user_sessions[user_id]
        
        # ØªØ­Ø¯ÙŠØ« Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
        await query.edit_message_text(
            "â¬‡ï¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±ØŒ Ù‚Ø¯ ØªØ³ØªØºØ±Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ø¶Ø¹ Ø¯Ù‚Ø§Ø¦Ù‚."
        )
        
        try:
            if data.startswith("video_"):
                quality = data.split("_")[1]
                file_path = await self.download_video(session['url'], quality)
            elif data.startswith("audio_"):
                file_path = await self.download_audio(session['url'])
            else:
                await query.edit_message_text("âŒ Ø®ÙŠØ§Ø± ØºÙŠØ± ØµØ­ÙŠØ­!")
                return
            
            if file_path and os.path.exists(file_path):
                # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù
                await self.send_file(query, file_path)
                
                # Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
                os.remove(file_path)
            else:
                await query.edit_message_text("âŒ ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù!")
                
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„: {e}")
            await query.edit_message_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„!")
        
        finally:
            # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¬Ù„Ø³Ø©
            if user_id in self.user_sessions:
                del self.user_sessions[user_id]

    async def download_video(self, url: str, quality: str) -> Optional[str]:
        """ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ø¬ÙˆØ¯Ø© Ù…Ø­Ø¯Ø¯Ø© Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø­Ø³Ù†Ø© Ù„Ù„Ø£Ø®Ø·Ø§Ø¡"""
        output_path = os.path.join(DOWNLOAD_PATH, f"video_{quality}p_%(title)s.%(ext)s")
        
        ydl_opts = self.get_ydl_opts(for_download=True)
        ydl_opts.update({
            'format': f'best[height<={quality}]/best',
            'outtmpl': output_path,
        })
        
        max_retries = 2
        for attempt in range(max_retries):
            try:
                if attempt > 0:
                    delay = random.uniform(3, 6)
                    logger.info(f"Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¨Ø¹Ø¯ {delay:.1f} Ø«Ø§Ù†ÙŠØ©...")
                    await asyncio.sleep(delay)
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = await asyncio.to_thread(ydl.extract_info, url, download=True)
                    filename = ydl.prepare_filename(info)
                    
                    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ù„Ù
                    if os.path.exists(filename):
                        return filename
                    
                    # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ù„Ù Ø¨Ø§Ù…ØªØ¯Ø§Ø¯Ø§Øª Ù…Ø®ØªÙ„ÙØ©
                    base_name = os.path.splitext(filename)[0]
                    for ext in ['.mp4', '.webm', '.mkv', '.avi']:
                        test_file = base_name + ext
                        if os.path.exists(test_file):
                            return test_file
                    
                    logger.error(f"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø­Ù…Ù„: {filename}")
                    
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (Ù…Ø­Ø§ÙˆÙ„Ø© {attempt + 1}): {e}")
                if attempt == max_retries - 1:
                    return None
        
        return None

    async def download_audio(self, url: str) -> Optional[str]:
        """ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª ÙÙ‚Ø· Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø­Ø³Ù†Ø© Ù„Ù„Ø£Ø®Ø·Ø§Ø¡"""
        output_path = os.path.join(DOWNLOAD_PATH, "audio_%(title)s.%(ext)s")
        
        ydl_opts = self.get_ydl_opts(for_download=True)
        ydl_opts.update({
            'format': 'bestaudio/best',
            'outtmpl': output_path,
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'mp3',
                'preferredquality': '192',
            }],
        })
        
        max_retries = 2
        for attempt in range(max_retries):
            try:
                if attempt > 0:
                    delay = random.uniform(3, 6)
                    logger.info(f"Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª Ø¨Ø¹Ø¯ {delay:.1f} Ø«Ø§Ù†ÙŠØ©...")
                    await asyncio.sleep(delay)
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = await asyncio.to_thread(ydl.extract_info, url, download=True)
                    filename = ydl.prepare_filename(info)
                    
                    # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ù„Ù MP3
                    audio_filename = os.path.splitext(filename)[0] + '.mp3'
                    if os.path.exists(audio_filename):
                        return audio_filename
                    
                    # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ù„ÙØ§Øª ØµÙˆØªÙŠØ© Ø£Ø®Ø±Ù‰
                    base_name = os.path.splitext(filename)[0]
                    for ext in ['.m4a', '.webm', '.ogg', '.wav']:
                        test_file = base_name + ext
                        if os.path.exists(test_file):
                            return test_file
                    
                    logger.error(f"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ: {audio_filename}")
                    
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª (Ù…Ø­Ø§ÙˆÙ„Ø© {attempt + 1}): {e}")
                if attempt == max_retries - 1:
                    return None
        
        return None

    async def send_file(self, query, file_path: str):
        """Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        file_size = os.path.getsize(file_path)
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù (Ø­Ø¯ ØªÙ„Ø¬Ø±Ø§Ù… 50 Ù…ÙŠØ¬Ø§)
        if file_size > 50 * 1024 * 1024:
            await query.edit_message_text(
                "âŒ Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹ (Ø£ÙƒØ«Ø± Ù…Ù† 50 Ù…ÙŠØ¬Ø§)!\n"
                "ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø¬ÙˆØ¯Ø© Ø£Ù‚Ù„."
            )
            return
        
        filename = os.path.basename(file_path)
        
        try:
            if file_path.endswith('.mp3'):
                # Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ…Ù„Ù ØµÙˆØªÙŠ
                with open(file_path, 'rb') as audio_file:
                    await query.message.reply_audio(
                        audio=audio_file,
                        caption="ğŸµ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„ØµÙˆØªÙŠ Ø¨Ù†Ø¬Ø§Ø­!",
                        filename=filename
                    )
            else:
                # Ø¥Ø±Ø³Ø§Ù„ ÙƒÙÙŠØ¯ÙŠÙˆ
                with open(file_path, 'rb') as video_file:
                    await query.message.reply_video(
                        video=video_file,
                        caption="ğŸ“¹ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ù†Ø¬Ø§Ø­!",
                        filename=filename
                    )
            
            await query.edit_message_text("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­!")
            
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù: {e}")
            await query.edit_message_text("âŒ ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù!")

    def format_duration(self, seconds: int) -> str:
        """ØªÙ†Ø³ÙŠÙ‚ Ù…Ø¯Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ"""
        if not seconds:
            return "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
        
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        seconds = seconds % 60
        
        if hours > 0:
            return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
        else:
            return f"{minutes:02d}:{seconds:02d}"

def main():
    """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""
    if not BOT_TOKEN:
        print("âŒ Ø®Ø·Ø£: Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ BOT_TOKEN ÙÙŠ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©!")
        return
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª
    bot = YouTubeTelegramBot()
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£ÙˆØ§Ù…Ø±
    application.add_handler(CommandHandler("start", bot.start_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_url))
    application.add_handler(CallbackQueryHandler(bot.handle_callback))
    
    print("ğŸš€ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")
    print("ğŸ“ Ø£Ø±Ø³Ù„ /start Ù„Ù„Ø¨Ø¯Ø¡")
    
    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
